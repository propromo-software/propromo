<?php

namespace App\Services;

use App\Models\Monitor;
use App\Models\Vulnerability;
use Exception;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

/**
 * Class VulnerabilityService.
 */
class VulnerabilityService
{
    /**
     * @throws Exception
     */
    public function collect_vulnerabilities(Monitor $monitor)
    {
        $url = $monitor->type == 'ORGANIZATION'
            ? $_ENV['APP_SERVICE_URL'] . '/v1/github/orgs/' . $monitor->organization_name . '/projects/' . $monitor->project_identification . '/repositories/vulnerabilities?rootPageSize=25'
            : $_ENV['APP_SERVICE_URL'] . '/v1/github/users/' . $monitor->login_name . '/projects/' . $monitor->project_identification . '/repositories/vulnerabilities?rootPageSize=25';

        try {
            $response = Http::withHeaders([
                'content-type' => 'application/json',
                'Accept' => 'text/plain',
                'Authorization' => 'Bearer ' . $monitor->pat_token
            ])->get($url);

            Log::debug('Raw API Response:', [
                'status' => $response->status(),
                'body' => $response->body()
            ]);

            if ($response->successful()) {
                $monitor->vulnerabilities()->delete();
                $processedKeys = [];

                $repositories = $response->json()['data']['organization']['projectV2']['repositories']['nodes'] ?? [];
                $totalCount = 0;

                foreach ($repositories as $repo) {
                    $vulnerabilityAlerts = $repo['vulnerabilityAlerts'] ?? [];
                    $totalCount += $vulnerabilityAlerts['totalCount'] ?? 0;
                    $vulnerabilities = $vulnerabilityAlerts['nodes'] ?? [];

                    Log::debug('Processing repo:', [
                        'name' => $repo['name'],
                        'totalCount' => $vulnerabilityAlerts['totalCount'] ?? 0,
                        'foundNodes' => count($vulnerabilities)
                    ]);

                    foreach ($vulnerabilities as $vulnData) {
                        if (!isset($vulnData['securityVulnerability'])) {
                            Log::warning('Missing securityVulnerability data for vulnerability in repo ' . $repo['name']);
                            continue;
                        }

                        $securityVuln = $vulnData['securityVulnerability'];
                        $advisory = $securityVuln['advisory'] ?? [];
                        $package = $securityVuln['package'] ?? [];

                        // Create unique key based on summary, ecosystem and package name
                        $key = md5(
                            ($advisory['summary'] ?? '') . '|' .
                            ($package['ecosystem'] ?? '') . '|' .
                            ($package['name'] ?? '')
                        );

                        // Skip if we've already processed this combination
                        if (in_array($key, $processedKeys)) {
                            Log::debug('Skipping duplicate vulnerability', [
                                'repo' => $repo['name'],
                                'package' => $package['name'] ?? 'unknown',
                                'summary' => $advisory['summary'] ?? ''
                            ]);
                            continue;
                        }

                        $processedKeys[] = $key;

                        $vulnerability = new Vulnerability([
                            'repository_name' => $repo['name'],
                            'package_name' => $package['name'] ?? 'unknown',
                            'ecosystem' => $package['ecosystem'] ?? 'unknown',
                            'classification' => $advisory['classification'] ?? 'unknown',
                            'summary' => $advisory['summary'] ?? '',
                            'description' => $advisory['description'] ?? '',
                            'vulnerable_version_range' => $securityVuln['vulnerableVersionRange'] ?? '',
                            'first_patched_version' => $securityVuln['firstPatchedVersion']['identifier'] ?? null,
                            'dependency_scope' => $vulnData['dependencyScope'] ?? 'unknown',
                            'fixed_at' => $vulnData['fixedAt'] ?? null,
                            'published_at' => $advisory['publishedAt'] ?? now(),
                            'updated_at' => $securityVuln['updatedAt'] ?? now(),
                            'created_at' => $vulnData['createdAt'] ?? now(),
                            'monitor_id' => $monitor->id
                        ]);

                        $monitor->vulnerabilities()->save($vulnerability);
                    }
                }

                Log::info('Vulnerability collection completed', [
                    'total_count' => $totalCount,
                    'unique_count' => count($processedKeys),
                    'loaded_count' => $monitor->vulnerabilities()->count()
                ]);

                return [
                    'vulnerabilities' => $monitor->vulnerabilities()->get(),
                    'total_count' => count($processedKeys)
                ];
            } else {
                if (app()->environment('local')) {
                    throw new Exception("Failed to fetch vulnerabilities for " . $monitor->title . "! " . $response->body());
                } else {
                    throw new Exception("Failed to fetch vulnerabilities for " . $monitor->title . "!");
                }
            }
        } catch (Exception $e) {
            Log::error('Vulnerability collection error:', [
                'message' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            throw $e;
        }
    }
}
